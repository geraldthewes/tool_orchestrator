{"question": "Review this function for bugs: def add(a, b): return a - b", "answer": "Bug found: The function is named 'add' but performs subtraction. Should use '+' instead of '-'.", "expected_keywords": ["bug", "subtraction", "+"], "tool": "ask_coder", "category": "delegate"}
{"question": "Is this code thread-safe? counter = 0; def increment(): global counter; counter += 1", "answer": "Not thread-safe. The increment operation is not atomic. Use locks or atomic operations.", "expected_keywords": ["thread", "safe", "atomic", "lock"], "tool": "ask_coder", "category": "delegate"}
{"question": "Review this SQL for injection vulnerabilities: query = f'SELECT * FROM users WHERE id = {user_id}'", "answer": "SQL injection vulnerability. Use parameterized queries instead of string formatting.", "expected_keywords": ["SQL", "injection", "parameterized"], "tool": "ask_coder", "category": "delegate"}
{"question": "Check this Python code for issues: with open('file.txt') as f: data = f.read(); return data", "answer": "Syntax error: 'return' cannot be used outside a function. Also consider error handling for file operations.", "expected_keywords": ["return", "function", "error"], "tool": "ask_coder", "category": "delegate"}
{"question": "Why might this code cause a memory leak: while True: data.append(fetch_data())", "answer": "The list grows indefinitely without clearing. Data is never removed, causing memory exhaustion.", "expected_keywords": ["memory", "leak", "grows", "clear"], "tool": "ask_coder", "category": "delegate"}
{"question": "Debug: for i in range(len(lst)): if lst[i] == target: lst.remove(lst[i])", "answer": "Modifying list while iterating causes index issues. Use list comprehension or iterate backwards.", "expected_keywords": ["modify", "iterate", "index"], "tool": "ask_coder", "category": "delegate"}
{"question": "Why does this return None: def greet(name): print(f'Hello {name}')", "answer": "The function uses 'print' instead of 'return'. Print outputs to console but returns None.", "expected_keywords": ["print", "return", "None"], "tool": "ask_coder", "category": "delegate"}
{"question": "Write a Python decorator that logs function execution time", "answer": "A decorator using functools.wraps that records start time, calls function, calculates duration, and logs it.", "expected_keywords": ["decorator", "time", "functools", "log"], "tool": "ask_coder", "category": "delegate"}
{"question": "Create a Python context manager for database transactions", "answer": "A context manager that begins transaction on __enter__, commits on success, and rolls back on exception.", "expected_keywords": ["context", "manager", "commit", "rollback"], "tool": "ask_coder", "category": "delegate"}
{"question": "Write a retry decorator with exponential backoff", "answer": "A decorator that catches exceptions, waits with exponential delay, and retries up to a max count.", "expected_keywords": ["retry", "exponential", "backoff", "exception"], "tool": "ask_coder", "category": "delegate"}
{"question": "Please review this Python function for errors:\n```python\n\ndef factorial(n):\n    return n * factorial(n - 1)\n```", "answer": "Bug found: The function lacks a base case (e.g., `if n <= 1: return 1`). Without it, the recursion never stops and causes a RecursionError. Add a condition to return 1 when `n` is 0 or 1, then perform the recursive multiplication.\n```python\n\ndef factorial(n):\n    if n <= 1:\n        return 1\n    return n * factorial(n - 1)\n```", "expected_keywords": ["bug", "base case", "recursion", "return 1"], "tool": "ask_coder", "category": "delegate"}
{"question": "Check this JavaScript code for sorting an array of numbers:\n```javascript\nfunction sortNumbers(arr) {\n    return arr.sort();\n}\n```", "answer": "Bug found: `Array.prototype.sort()` without a comparator sorts elements as strings, leading to lexicographic ordering (e.g., `[10, 2, 30]` becomes `[10, 2, 30]`). Use a numeric comparator to sort numbers correctly:\n```javascript\nfunction sortNumbers(arr) {\n    return arr.sort((a, b) => a - b);\n}\n```", "expected_keywords": ["bug", "lexicographic", "sort", "numeric comparator", "a - b"], "tool": "ask_coder", "category": "delegate"}
{"question": "Is this Python code safe for concurrent use? items = []\n\ndef add_item(x):\n    items.append(x)", "answer": "No, it is not thread-safe. The list.append operation is not guaranteed to be atomic, so concurrent calls can corrupt the list. Use a threading.Lock to protect the append or switch to a thread-safe collection.", "expected_keywords": ["thread", "race", "list", "lock", "atomic"], "tool": "ask_coder", "category": "delegate"}
{"question": "Is the following Java singleton implementation thread\u2011safe?\n\nprivate static MySingleton instance;\n\npublic static MySingleton getInstance() {\n    if (instance == null) {\n        synchronized (MySingleton.class) {\n            if (instance == null) {\n                instance = new MySingleton();\n            }\n        }\n    }\n    return instance;\n}", "answer": "No, this double\u2011checked locking pattern is not thread\u2011safe without declaring `instance` as `volatile`. Without `volatile`, a thread may see a partially constructed object. Add `private static volatile MySingleton instance;` or use an enum/single\u2011holder pattern for a safe singleton.", "expected_keywords": ["thread", "safe", "volatile", "singleton", "double-checked"], "tool": "ask_coder", "category": "delegate"}
{"question": "Review this Python function for thread\u2011safety issues: \n```python\ncount = 0\n\ndef increment():\n    global count\n    count += 1\n```", "answer": "The function has a race condition because multiple threads can modify the global `count` simultaneously, leading to lost updates. Protect the increment with a `threading.Lock` or use atomic primitives like `queue.SimpleQueue` for safe increments. Example:\n```python\nimport threading\ncount = 0\nlock = threading.Lock()\n\ndef increment():\n    global count\n    with lock:\n        count += 1\n```", "expected_keywords": ["thread", "race condition", "lock", "threading"], "tool": "ask_coder", "category": "delegate"}
{"question": "Analyze this JavaScript snippet for XSS vulnerabilities: \n```html\n<div id=\"output\"></div>\n<script>\n  const userInput = location.hash.substring(1);\n  document.getElementById('output').innerHTML = userInput;\n</script>\n```", "answer": "Assigning `userInput` directly to `innerHTML` creates a reflected XSS risk because an attacker can inject malicious HTML/JS via the URL hash. Use `textContent` or sanitize the input before inserting it into the DOM. Example:\n```javascript\nconst safeText = document.createTextNode(userInput);\nconst output = document.getElementById('output');\noutput.textContent = '';\noutput.appendChild(safeText);\n```", "expected_keywords": ["XSS", "sanitization", "innerHTML", "textContent"], "tool": "ask_coder", "category": "delegate"}
{"question": "Review this JavaScript snippet:\n```js\nasync function fetchData(url) {\n  const response = fetch(url);\n  const data = response.json();\n  return data;\n}\n```\nWhat problems does it have?", "answer": "The function is declared as `async` but it never uses `await`, so `fetch(url)` returns a Promise that isn\u2019t resolved before you try to call `response.json()`. Both the network request and the JSON parsing need to be awaited:\n```js\nasync function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  return data;\n}\n```\nAdditionally, consider adding error handling (try/catch) to deal with network failures or invalid JSON.", "expected_keywords": ["await", "async", "fetch", "error handling"], "tool": "ask_coder", "category": "delegate"}
{"question": "Inspect this SQL query intended to count employees per department:\n```sql\nSELECT department, COUNT(*)\nFROM employees\nWHERE salary > 50000;\n```\nWhat is missing or incorrect?", "answer": "The query selects `department` together with an aggregate function `COUNT(*)` but does not include a `GROUP BY` clause. Without grouping, the SQL engine cannot determine how to aggregate rows per department, resulting in a syntax error in most databases. The corrected query is:\n```sql\nSELECT department, COUNT(*)\nFROM employees\nWHERE salary > 50000\nGROUP BY department;\n```\nThis groups rows by `department` before applying the `COUNT` aggregate. You may also want to alias the count column for clarity, e.g., `COUNT(*) AS employee_count`.", "expected_keywords": ["GROUP BY", "aggregate", "COUNT", "syntax"], "tool": "ask_coder", "category": "delegate"}
{"question": "What is wrong with this snippet that could cause a memory issue?\n```python\n\ndef traverse(node, visited=[]):\n    visited.append(node)\n    for child in node.children:\n        traverse(child, visited)\n    return visited\n```", "answer": "The function uses a mutable default argument (the list `visited`). Because default arguments are evaluated only once, the same list is reused across all calls, causing nodes to be continuously appended without ever being cleared. In recursive traversals, especially on large or cyclic graphs, this leads to the list growing without bound, eventually exhausting memory. The fix is to use `None` as the default and create a new list inside the function, or to pass an explicitly created collection each time and guard against cycles.", "expected_keywords": ["mutable", "default", "list", "accumulate", "memory", "leak", "recursion"], "tool": "ask_coder", "category": "delegate"}
{"question": "In a data\u2011processing loop we have the following code. What problem might it cause regarding memory?\n```python\nimport pandas as pd\n\ndf = pd.DataFrame()\nfor i in range(10000):\n    df = df.append(get_chunk(i))\n```", "answer": "Each call to `df.append()` creates a brand\u2011new DataFrame that copies all existing data and adds the new chunk. Over 10,000 iterations this results in repeated copying and the DataFrame growing quadratically in size, quickly consuming all available memory. The pattern causes a memory\u2011exhaustion issue. A better approach is to collect the chunks in a list and concatenate them once with `pd.concat`, or pre\u2011allocate a list of DataFrames and combine them after the loop.", "expected_keywords": ["append", "DataFrame", "copy", "grow", "memory", "exhaustion", "inefficient"], "tool": "ask_coder", "category": "delegate"}
