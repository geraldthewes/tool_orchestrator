{"question": "Analyze the pros and cons of microservices vs monolithic architecture", "answer": "Microservices offer scalability and independent deployment but add complexity. Monoliths are simpler but harder to scale.", "expected_keywords": ["microservices", "monolith", "scalability"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "What are the trade-offs between eventual consistency and strong consistency?", "answer": "Strong consistency ensures immediate data accuracy but reduces availability. Eventual consistency improves performance but allows temporary inconsistencies.", "expected_keywords": ["consistency", "availability", "trade-off"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "Explain the CAP theorem and its implications for distributed systems", "answer": "CAP theorem states distributed systems can only guarantee two of: Consistency, Availability, Partition tolerance.", "expected_keywords": ["CAP", "consistency", "availability", "partition"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "What factors should be considered when choosing between SQL and NoSQL databases?", "answer": "Consider data structure, scalability needs, ACID requirements, query complexity, and team expertise.", "expected_keywords": ["SQL", "NoSQL", "ACID", "scalability"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "Analyze the impact of technical debt on software development", "answer": "Technical debt slows development, increases bugs, and reduces maintainability. Regular refactoring is essential.", "expected_keywords": ["technical", "debt", "refactoring"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "If all programmers are logical, and Alice is a programmer, what can we conclude about Alice?", "answer": "Alice is logical, based on the logical deduction from the given premises.", "expected_keywords": ["Alice", "logical"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "A company has 100 employees. 60% work remotely, 40% are engineers. If 30% of engineers work remotely, what percentage of remote workers are engineers?", "answer": "12 engineers work remotely out of 60 remote workers, so 20% of remote workers are engineers.", "expected_keywords": ["20%", "engineers", "remote"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "Explain step by step how to debug a memory leak in a Node.js application", "answer": "Use heap snapshots, memory profilers, identify retention paths, and fix references preventing garbage collection.", "expected_keywords": ["heap", "memory", "profiler", "garbage"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "Walk me through the process of designing a rate limiting system", "answer": "Consider token bucket or sliding window algorithms, storage (Redis), configuration, and handling of exceeded limits.", "expected_keywords": ["token", "bucket", "Redis", "limit"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "How would you approach migrating a monolithic database to microservices?", "answer": "Start with bounded contexts, use strangler fig pattern, implement data synchronization, and migrate incrementally.", "expected_keywords": ["strangler", "bounded", "context", "incremental"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "What's the best approach to refactor a 10k line legacy codebase?", "answer": "Add tests first, identify seams, extract modules incrementally, maintain backwards compatibility.", "expected_keywords": ["test", "refactor", "incremental"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "How should a startup prioritize feature development with limited resources?", "answer": "Use impact vs effort matrix, focus on MVP, gather user feedback, iterate quickly.", "expected_keywords": ["MVP", "impact", "effort", "feedback"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "What strategy would you recommend for handling high availability requirements?", "answer": "Implement redundancy, load balancing, failover mechanisms, health checks, and disaster recovery.", "expected_keywords": ["redundancy", "failover", "load balancing"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "How do you design an effective code review process?", "answer": "Define guidelines, use automated checks, limit PR size, focus on constructive feedback, and track metrics.", "expected_keywords": ["review", "PR", "feedback", "automated"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "What approach would you take to improve application performance?", "answer": "Profile first, optimize bottlenecks, use caching, optimize queries, and consider horizontal scaling.", "expected_keywords": ["profile", "bottleneck", "cache", "optimize"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "Compare the advantages and disadvantages of using relational databases versus NoSQL databases for a real-time analytics platform handling 10 million events per day.", "answer": "Relational DBs provide strong consistency and support complex queries and joins, but they can struggle with horizontal scaling and very high write rates. NoSQL stores (e.g., Cassandra, DynamoDB) are designed for massive write loads and can scale horizontally with low latency, though they typically offer eventual consistency and limited support for multi\u2011table joins. For a workload of 10\u202fM events/day, a NoSQL solution may give better ingest performance, while a relational database might be preferable if the analytics require sophisticated ad\u2011hoc queries across many tables.", "expected_keywords": ["relational databases", "NoSQL", "consistency", "scalability", "real-time analytics"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "What are the main trade-offs between using container orchestration platforms like Kubernetes versus serverless frameworks such as AWS Lambda for a web service expected to handle up to 5,000 concurrent users?", "answer": "Kubernetes gives fine\u2011grained control over resources, networking, persistent storage, and supports custom runtimes, making it suitable for steady, long\u2011running workloads, but it requires cluster provisioning, management, and incurs higher operational overhead. Serverless platforms like AWS Lambda abstract away the infrastructure, automatically scale to thousands of concurrent invocations and charge per execution, but they introduce cold\u2011start latency, have execution time limits, and provide less control over the runtime environment. For 5\u202fk concurrent users, serverless can simplify scaling and reduce ops effort, while Kubernetes may be preferred when low latency, long\u2011running processes, or specific runtime configurations are needed.", "expected_keywords": ["Kubernetes", "AWS Lambda", "serverless", "container orchestration", "scaling", "cold start"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "How does increasing the replication factor from 3 to 5 affect the trade\u2011off between consistency and availability in a distributed key\u2011value store using quorum reads and writes?", "answer": "Raising the replication factor to 5 allows larger read and write quorums, which can improve consistency because more replicas must agree before an operation succeeds. However, larger quorums also increase the chance that a node or network partition will prevent a quorum from forming, reducing availability and adding latency. Thus, the system can achieve stronger consistency at the cost of lower availability and higher response times.", "expected_keywords": ["consistency", "availability", "replication factor", "quorum", "trade-off", "latency"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "In a multi\u2011region e\u2011commerce platform, what are the practical implications of choosing eventual consistency for product inventory counts versus strong consistency for order processing?", "answer": "Using eventual consistency for inventory allows updates to propagate asynchronously across regions, giving low\u2011latency reads and high availability, but may show stale stock levels, leading to overselling. Strong consistency for order processing ensures that each order sees the latest inventory, preventing overselling, but requires cross\u2011region coordination, increasing latency and reducing availability during network partitions. The platform must balance fast browsing (favoring eventual consistency) against accurate order fulfillment (favoring strong consistency).", "expected_keywords": ["consistency", "availability", "inventory", "order processing", "latency", "trade\u2011off"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "Compare linearizability and sequential consistency in terms of ordering guarantees for operations in a distributed system.", "answer": "Linearizability requires that each operation appear to take effect instantaneously at some point between its invocation and response, preserving real\u2011time order across all clients. Sequential consistency only guarantees that all processes observe operations in the same total order, but that order does not have to respect real\u2011time ordering.", "expected_keywords": ["linearizability", "sequential consistency", "ordering", "real\u2011time", "distributed system"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "In a Raft\u2011based replicated state machine, how many follower nodes are needed to tolerate a given number of failures, and what are the three core phases of the Raft protocol?", "answer": "Raft can tolerate f failures with a cluster of 2f+1 nodes, requiring a majority (f+1) of voters to commit log entries. The three core phases are leader election, log replication, and safety (which includes log commitment and optional log compaction via snapshots).", "expected_keywords": ["Raft", "2f+1", "majority", "leader election", "log replication", "safety", "snapshot"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "What should I evaluate when deciding between a relational database and a graph database for a social\u2011network application?", "answer": "Assess the depth and complexity of relationships in your data, the types of queries you\u2019ll run (e.g., traversals vs. joins), performance requirements for real\u2011time path finding, scalability patterns (horizontal vs. vertical), ACID guarantees versus eventual consistency, and the team's familiarity with graph query languages versus SQL.", "expected_keywords": ["relational", "graph database", "relationships", "traversals", "joins", "scalability", "ACID", "team expertise"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "Which factors are important when choosing a column\u2011oriented store over a traditional row\u2011oriented RDBMS for large\u2011scale analytics?", "answer": "Consider the workload\u2019s read\u2011heavy nature, the benefit of columnar compression for wide tables, query patterns that aggregate many rows but few columns, the need for fast scans versus point\u2011lookup latency, scalability through distributed nodes, cost of storage, and whether the system must support ACID transactions or can tolerate eventual consistency.", "expected_keywords": ["column\u2011oriented", "row\u2011oriented", "compression", "read\u2011heavy", "analytics", "scalability", "ACID", "point\u2011lookup"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "What are the consequences of race conditions in multithreaded applications, and how can they be mitigated?", "answer": "Race conditions cause nondeterministic behavior, leading to data corruption, crashes, and unexpected performance degradation. They make debugging difficult because bugs appear intermittently. Mitigation strategies include using proper synchronization primitives such as mutexes, semaphores, and read\u2011write locks, employing atomic operations, designing lock\u2011free data structures, and applying rigorous concurrency testing (e.g., stress tests and static analysis).", "expected_keywords": ["race conditions", "multithreaded", "synchronization", "data corruption"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "How does accumulating technical debt in ETL pipelines affect data latency and error rates over a 12\u2011month period, and what quantitative benefits can be achieved by allocating 15% of sprint capacity to refactoring?", "answer": "When technical debt builds up in ETL pipelines, data latency typically rises by 20\u201130\u202f% over a year as ad\u2011hoc scripts and brittle joins slow processing. Error rates also climb, often increasing by about 35\u202f% due to undocumented schema changes and missing validations. Dedicating roughly 15\u202f% of each sprint to refactoring\u2014such as modularizing transformations, adding schema enforcement, and replacing legacy scripts\u2014can cut latency by up to 22\u202f% and reduce error rates by around 40\u202f%, restoring pipeline reliability and speed.", "expected_keywords": ["ETL", "technical debt", "latency", "refactoring"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "All marine biologists study ocean life, and Dr. Patel is a marine biologist. What can we conclude about Dr. Patel?", "answer": "Dr. Patel studies ocean life, based on the direct logical deduction from the premise.", "expected_keywords": ["Dr. Patel", "studies ocean life"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "In a software team, every senior developer knows Python, all developers who know Python can debug code, and Maya is a senior developer. What can we conclude about Maya's ability to debug code?", "answer": "Maya can debug code, because she is a senior developer (so she knows Python) and anyone who knows Python can debug code.", "expected_keywords": ["Maya", "debug code"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "A university has 800 students. 55% are undergraduates and 45% are graduate students. 30% of undergraduates are international, while 20% of graduate students are international. What percentage of the international students are undergraduates?", "answer": "There are 800\u202f\u00d7\u202f0.55\u202f=\u202f440 undergraduates, of which 30% are international \u2192 440\u202f\u00d7\u202f0.30\u202f=\u202f132 international undergraduates. There are 800\u202f\u00d7\u202f0.45\u202f=\u202f360 graduate students, of which 20% are international \u2192 360\u202f\u00d7\u202f0.20\u202f=\u202f72 international graduate students. Total international students = 132\u202f+\u202f72\u202f=\u202f204. The share that are undergraduates is 132\u202f/\u202f204\u202f\u2248\u202f0.647, i.e., about 65%.", "expected_keywords": ["65%", "undergraduates", "international"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "A hospital employs 250 staff members. 70% are nurses and 40% are doctors. If 25% of the doctors also serve as nurses, what percentage of the nurses are also doctors?", "answer": "Total nurses = 250\u202f\u00d7\u202f0.70\u202f=\u202f175. Total doctors = 250\u202f\u00d7\u202f0.40\u202f=\u202f100. Doctors who are also nurses = 25% of 100 = 25. Therefore, nurses who are also doctors = 25 out of 175 nurses, which is 25\u202f/\u202f175\u202f\u2248\u202f0.143, or about 14% of the nurses.", "expected_keywords": ["14%", "nurses", "doctors"], "tool": "ask_reasoner", "category": "delegate"}
{"question": "What are the step\u2011by\u2011step actions to decide the optimal number of shards for a PostgreSQL database that must support roughly 10,000 concurrent reads and 2,000 writes per second?", "answer": "1. Profile the workload: measure average read/write size, query patterns, and latency targets. 2. Estimate total throughput (reads\u202f+\u202fwrites) and compare it to a single node\u2019s I/O and CPU limits. 3. Calculate the maximum rows/transactions a single node can handle without exceeding latency goals. 4. Divide the required throughput by the per\u2011node capacity to get a baseline shard count. 5. Consider hardware constraints (CPU cores, RAM, SSD IOPS) and add a safety margin (e.g., 20\u202f%). 6. Evaluate data distribution: choose a partitioning key that balances load evenly across shards. 7. Run a small\u2011scale test cluster with the calculated shard count and monitor latency, throughput, and replication lag. 8. Adjust the number of shards up or down based on observed performance and operational cost.", "expected_keywords": ["shards", "throughput", "latency", "partitioning", "replication"], "tool": "ask_reasoner", "category": "delegate"}
